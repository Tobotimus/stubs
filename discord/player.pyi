import threading
from typing import Any, Union, Optional, Callable, BinaryIO
from .voice_client import VoiceClient

_Finalizer = Callable[[Optional[Exception]], Any]

class AudioSource:
    def read(self) -> bytes: ...
    def is_opus(self) -> bool: ...
    def cleanup(self) -> None: ...
    def __del__(self) -> None: ...

class PCMAudio(AudioSource):
    stream: BinaryIO = ...
    def __init__(self, stream: BinaryIO) -> None: ...
    def read(self) -> bytes: ...

class FFmpegPCMAudio(AudioSource):
    source: Union[str, BinaryIO] = ...
    executable: str = ...
    pipe: bool = ...
    stderr: Optional[BinaryIO] = ...
    options: Optional[str] = ...
    before_options: Optional[str] = ...
    def __init__(
        self,
        source: Union[str, BinaryIO],
        *,
        executable: str = ...,
        pipe: bool = ...,
        stderr: Optional[BinaryIO] = ...,
        before_options: Optional[str] = ...,
        options: Optional[str] = ...
    ) -> None: ...

class PCMVolumeTransformer(AudioSource):
    original: AudioSource = ...
    volume: float = ...
    def __init__(self, original: AudioSource, volume: float = ...) -> None: ...
    @property
    def volume(self) -> float: ...
    @volume.setter
    def volume(self, value: float) -> None: ...

class AudioPlayer(threading.Thread):
    DELAY: float = ...
    daemon: bool = ...
    source: AudioSource = ...
    client: VoiceClient = ...
    after: Optional[_Finalizer] = ...
    loops: int = ...
    def __init__(self, source: Any, client: Any, *, after: Optional[_Finalizer] = ...) -> None: ...
    def run(self) -> None: ...
    def stop(self) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def is_playing(self) -> bool: ...
    def is_paused(self) -> bool: ...
